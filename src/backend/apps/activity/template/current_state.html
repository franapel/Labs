{% extends '_partials/_base.html' %}
{% load static %}


{% block pagetitle %}Estado Actual{% endblock %}

{% block content %}

<div class="col-12">
    <div style="margin-left: auto; margin-right: auto;" class="card p-5 card-custom gutter-b example example-compact">

        <h1>Estado Actual</h1>

        <div class="d-flex justify-content-end">
            <select id="campus-select" style="width: 200px;" class="form-control mr-4">
                {% for campus in campuses %}
                <option value="{{ campus.id }}">{{ campus.name }}</option>
                {% endfor %}
            </select>

            <select id="room-select" style="width: 200px" class="form-control">
                {% for room in rooms %}
                <option value="{{ room.id }}">{{ room.room_name }}</option>
                {% endfor %}
            </select>
        </div>

        <div id="ws-container" class="p-10 d-flex flex-wrap justify-content-center"></div>

    </div>
</div>

{% endblock %}

{% block scripts %}
<script type="text/javascript" src="https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>

<script type="text/javascript">
    // Conectar WebSocket
    const webSocketUrl = `wss://${window.location.host}/ws/activity/enc/${encryptAES("iamadmin", "gUkXp2s5v8y/B?E(G+KbPeShVmYq3t6w")}`

    const campusSelect = document.getElementById("campus-select")
    const roomSelect = document.getElementById("room-select")
    const wsContainer = document.getElementById("ws-container")

    let workstations
    let disconnectedWorkstations = []
    let lastUpdate

    const drawWorkstations = () => {
        wsContainer.innerHTML = Object.entries(workstations).reduce((acc, curr) => {
            const [workstation, info] = curr
            const noHistory = !info
            const hasEnd = info && info.end
            const oldAlive = info && info.alive && info.alive < moment().valueOf() - 1000 * 60 * 2
            const disconnected = disconnectedWorkstations.includes(workstation)
            const color = noHistory || hasEnd ? "border-light" : oldAlive || disconnected ? "border-warning" : "border-success"
            const message = noHistory ? "No hay historial"
                : hasEnd ? `Fin: ${moment(info.end).format("HH:mm:ss DD/MM/YYYY")}`
                    : oldAlive ? "Última señal de vida expirada"
                        : disconnected ? "El Websocket se ha desconectado"
                            : "Encendido"
            return acc + `
            <div style="width: 250px; height: 200px;" class="d-flex">

                <div style="width: 200px; height: 150px;"
                    class="py-5 d-flex flex-column align-items-center border border-5 rounded ${color}">
                    <h6 class="mb-5">${workstation}</h6>
                    ${info
                    ? ` <p>Inicio: ${moment(info.start).format("HH:mm:ss DD/MM/YYYY")}</p>
                        <p class="text-center">${message}`
                    : `<p>${message}</p>`
                }
                </div>

            </div>
            `
        }, "")
    }

    const loadData = (e) => {
        lastUpdate = moment().valueOf()
        const target = e && e.target && e.target.id
        let error = false
        const params = { campus: campusSelect.value }
        if (roomSelect.value) params.room = roomSelect.value
        fetch("{% url 'getstate' %}?" + new URLSearchParams(params))
            .then((response) => {
                if (response.status > 299) error = true
                return response.json()
            })
            .then((data) => {
                if (error || data.rooms.length == 0) {
                    wsContainer.innerHTML = "<div>Sin datos</div>"
                    roomSelect.innerHTML = ""
                } else {
                    if (target === "campus-select")
                        roomSelect.innerHTML = data.rooms.reduce((acc, curr) => acc +
                            `<option value="${curr.id}">${curr.room_name}</option>`,
                            "")
                    workstations = data.workstations
                    disconnectedWorkstations = []
                    console.log("draw")
                    drawWorkstations()
                }
            })
    }

    // Primer render
    loadData()
    connectWebSocket(webSocketUrl)

    // Actualizar los datos si no se han actualizado en los últimos dos minutos.
    setInterval(() => {
        if (lastUpdate < moment().valueOf() - 1000 * 60 * 0.5)
            loadData()
        
    }, 1000 * 60 * 1)

    // Al cambiar el campus, cambiar rooms y workstations
    campusSelect.onchange = loadData
    roomSelect.onchange = loadData

    function connectWebSocket(url) {
        const socket = new WebSocket(url)

        // Función que se ejecuta cuando se establece la conexión con éxito
        socket.onopen = (event) => {
            console.log("Conexión WebSocket establecida")
        }

        // Función que se ejecuta cuando se cierra la conexión
        socket.onclose = (event) => {
            console.log("Conexión WebSocket cerrada")
        }

        // Función que se ejecuta cuando se recibe un mensaje del servidor
        socket.onmessage = (event) => {
            const data = JSON.parse(event.data)
            const { workstation, type } = data
            if (type === "alive") {
                const ws = workstations[workstation]
                if (!ws) return
                const { info } = ws
                const oldAlive = info && info.alive && info.alive < moment().valueOf() - 1000 * 60 * 2
                const isNotAlive = !info || oldAlive || disconnectedWorkstations.includes(workstation)
                if (Object.keys(workstations).includes(workstation) && isNotAlive)
                    loadData()
            } else if (type === "disconnect") {
                disconnectedWorkstations.push(workstation)
                drawWorkstations()
            }
        }

        // Función que se ejecuta cuando se produce un error en la conexión
        socket.onerror = (event) => {
            console.error("Error de WebSocket:", event)
        }

        return socket
    }

    function encryptAES(plaintext, key) {
        // Agregar padding al texto para que calce con los 16 bits que pide CBC
        const paddingLength = 16 - (plaintext.length % 16) // Longitud del padding
        const padding = String.fromCharCode(paddingLength).repeat(paddingLength) // Crea el padding con el byte de relleno
        plaintext = plaintext + padding

        // Convertir la clave y el IV a buffers
        key = new TextEncoder().encode(key)
        iv = new Uint8Array(16)

        // Convertir el texto plano a un Uint8Array
        plaintext = new TextEncoder().encode(plaintext)

        // Crear una instancia de AES-256-CBC
        const aesCbc = new aesjs.ModeOfOperation.cbc(key, iv)

        // Encriptar el texto plano
        const encryptedBytes = aesCbc.encrypt(plaintext)

        // Convertir el resultado en un string Base64
        const encryptedBase64 = btoa(String.fromCharCode.apply(null, encryptedBytes))

        return encryptedBase64
    }

</script>

{% endblock %}